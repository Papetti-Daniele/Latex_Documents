\chapter{Introduzione}
Windows $\longrightarrow$ tutto è un oggetto(c++)\\
Linux $\longrightarrow$ tutto è un file\\
Perfino i processi sono descritti da file nelle cartelle denominate con il PID.
La filosofia è avere molti programmi piccoli e ottimizati che fanno poche cose. Quello che in windows è un servizio, in Linux è un deamon.\\
Il simbolo | permette di passare un output come input di un comando successivo.\\
I nomi delle variabili non dovrebbero contenere spazi, se voglio usare spazi devo mettere il nome tra " "\\

\textit{man} seguito dal comando mostra la help del comando (Es: man ls).
Per cercare all'interno del manale uso /paroladacercare e premo invio. Mi muovo nelle pagine con barraspazziatrice, esco con q\\

Posso usare ctrl+r e scrivere l'inizio di un vecchio comando per recuperarlo\\


\chapter{Comandi}
\section{Cartelle e file}
\begin{description}
\item [/] è la radice\\
\item [dev] è la cartella con i device\\
\item [ls] mostra elenco file nella directory. Varie opzioni, lh aggiunge dettagli, a per i file nascosti\\
\item [pwd] mostra il percorso assoluto alla cartella\\
\item [cd] permette di muoversi nelle cartelle\\
\item [mkdir] crea cartelle: l'opzione -p crea anche directory più esterne se fornisco una path\\
\item [rm] elimina un file/cartella(se forzato e ricorsivo): -f forza il comando, -r è ricorsivo\\
\item [mv] rinomina il file o lo sposta. Si chiama mv vecchionome nuovonome. Esempio(mv prova ../../) sposta indietro di due cartelle\\


\end{description}

\section{File}
\begin{description}
\item [touch nomefile] crea un file	\\
\item [vi] è un editor di testo. I per iniziare a scrivere, scrico, esc per uscire dalla scrittura, x per cancellare. Per salvare, entro nella linea di comando con :, w per salvare, q per uscire.\\
\item [nano] editor di testo più avanzato. Comandi con ctrl + lettera consigliata. Salva all'uscita
\item [cat] mostra il contenuto del file\\
\item [less] seguito dal nome del file da aprire, apre il file nella riga di comando. Col / faccio partire una ricerca\\
\item [test] verifica che il file esista e abbia certe proprietà che specifico nelle opzioni. Restituisce 1 se è corretto, 0 se no. 
\textit{test -f nomefile} verifica che esista il file, -s permette di specificare una dimensione minima, -r permette di indicare se è leggibile
\item [head] restituisce le prime righe del file
\item[tail] restituisce le ultime righe del file
\end{description}

\section{Permessi}
Con il comando ls -l vedo i permessi del file o cartella. I due nomi a fianco alle lettere indicano in ordine il possessore del file, il secondo il gruppo a cui appartiene il file.
I gruppi di lettere sono 3(user, gruppo, other). Le lettere rappresentano read, write e execute(attraversamento se è una cartella).\\
Lo user è il padrone del file, il gruppo è un insieme di utenti, other sono utenti fuori dal gruppo. I gruppi di 3 lettere sono modificabili come numeri binari. r è 4, w è 2, x è 1. Usando chmod valorepermessiutentevalorepermessigruppovalorepermessiother file, modifico questi permessi. Esempio: chmod 744 prova.txt\\
Per cambiare il proprietario di file/cartella uso chown nomeutente nomefile


\section{Utility}
\begin{description}
\item [gzip] comprime il file dato in input. Di default elimina il file originale, se voglio tenerlo devo usare -k
\item [gunzip] come sopra, ma decomprime
\item [grep] cerca una stringa in un file, restituisce le righe del file che la contengono
\item [time] prima di un comando restituisce il tempo di esecuzione
\item [| sort] ordina l'ouitput di un altro comando
\item [wc nomefile] conta il numero di righe, parole e caratteri di un file
\item [tar] è un programma che crea archivi compressi. Si invoca con \textit{tar cvzf nomeinoutput cartelladacomprimere}. Al posto di z posso usare j o J per aumentare il grado di compressione(aumenta anche il tempo richiesto per l'elaborazione)
\item [which] restituisce la path completa di un programma
\item [pwd] stampa la working directory
\item [htop] è il monitor di sistema
\end{description}

\chapter{Programmazione}
\section{Comandi}
!! esegue l'ultimo comando all'interno di un altro comando. Ecco un esempio:
\begin{tcolorbox}
sudo man !!
\end{tcolorbox}
Posso salvare l'output di un comando su file con \textit{comando > nomefile}\\
Se non c'è il file viene creato. Se uso >> non sovrascrivo ma concateno il l'output con il contenuto del file.

\begin{description}
\item [Ctrl + C] ferma il programma in esecuzione
\item [Ctrl + Z] mette in pausa il processo in esecuzione 
\item [fg] riprendere il programma messo in pausa
\end{description}
